# AI日记App架构与数据流设计

## 一、整体架构

AI日记App将采用典型的客户端-服务器架构 (Client-Server Architecture)，并集成第三方AI服务。主要组件包括：

1.  **客户端 (Frontend):**
    *   **平台:** 移动应用 (iOS, Android)，可考虑Web应用作为补充。
    *   **技术栈示例:** React Native / Flutter (跨平台移动开发)，或原生开发 (Swift/Kotlin)，Vue.js / React (Web)。
    *   **职责:**
        *   用户界面 (UI) 渲染与用户体验 (UX) 交互。
        *   本地数据缓存与离线支持 (例如：SQLite, Realm)。
        *   设备功能调用 (例如：相机、麦克风用于媒体附件和语音输入)。
        *   向后端API发起请求。
        *   管理用户会话和本地状态。

2.  **后端 (Backend):**
    *   **技术栈示例:** Python (Flask/Django), Node.js (Express.js), Java (Spring Boot), Ruby on Rails。
    *   **职责:**
        *   提供API接口 (RESTful 或 GraphQL) 供客户端调用。
        *   用户认证与授权 (例如：JWT, OAuth2)。
        *   业务逻辑处理 (日记、清单、用户管理等)。
        *   人脉关系管理逻辑 (联系人档案、互动记录、提醒、关系洞察、情商辅助等)。
        *   与数据库进行数据交互 (CRUD操作)。
        *   与第三方AI模型API进行集成和通信。
        *   管理AI模型API密钥 (安全存储，例如使用Vault或环境变量)。
        *   处理文件上传 (例如：图片、音频到云存储服务)。
    *   **(可考虑将不同业务逻辑拆分为微服务或明确的服务模块，例如：用户服务、日记服务、清单服务、人脉关系服务、AI集成服务等)**

3.  **数据库 (Database):**
    *   **类型示例:** 关系型数据库 (PostgreSQL, MySQL) 或 NoSQL数据库 (MongoDB)。考虑到用户、日记、清单之间的关系以及富文本内容的结构化存储需求，关系型数据库通常是较好的起点，但对于非结构化AI交互记录，NoSQL也可能适用。
    *   **职责:**
        *   持久化存储用户信息、日记条目 (包括不同类型的日记 `diary_type`、封面、背景、自定义设置 `custom_settings_json`)、清单 (包括不同类型的清单 `list_type`、进度、自定义设置)、标签、心情、媒体附件 (及其用途 `attachment_purpose`)、用户偏好设置、AI交互记录等。
        *   确保数据一致性、完整性和安全性。
        *   接收来自后端的文本输入或指令。
        *   执行自然语言处理任务 (内容生成、摘要、纠错、对话等)。
        *   返回处理结果给后端。

4.  **第三方AI服务 (External AI Services):**
    *   **提供商示例:** OpenAI (GPT系列), Anthropic (Claude系列), Google (Gemini系列), 以及其他可接入的开源或商业模型API。
    *   **职责:**
        *   接收来自后端的文本输入或指令。
        *   执行自然语言处理任务 (内容生成、摘要、纠错、对话等)。
        *   返回处理结果给后端。

5.  **云存储服务 (Cloud Storage - 可选但推荐):**
    *   **提供商示例:** Amazon S3, Google Cloud Storage, Azure Blob Storage。
    *   **职责:** 存储用户上传的媒体文件 (图片、音频、视频)，减轻数据库存储压力，并提供高效的文件访问。
    *   **客户端 (设备B):** 更新本地数据和UI。

## 二、数据流向 (关键用例)

以下是一些关键功能的数据流向示例：

1.  **用户注册/登录:**
    *   **客户端:** 用户输入注册信息 (邮箱、密码) 或登录凭据。
    *   **客户端 -> 后端API:** 发送注册/登录请求。
    *   **后端:**
        *   (注册) 验证信息，哈希密码，在数据库中创建用户记录。
        *   (登录) 验证凭据，与数据库中存储的用户信息比对。
        *   生成会话令牌 (例如JWT)。
    *   **后端API -> 客户端:** 返回成功/失败状态及会话令牌。
    *   **客户端:** 存储会话令牌，导航至主界面或显示错误信息。

2.  **创建日记条目 (手动):**
    *   **客户端:** 用户输入标题、富文本内容、选择心情、日记类型、添加标签、选择封面图片、设置背景、自定义参数、上传图片/音频等。
    *   **客户端 -> 后端API (文件上传):** 如果有媒体文件，先将文件上传至云存储 (或通过后端中转)，获取文件URL和 `attachment_id`。
    *   **客户端 -> 后端API (创建日记):** 发送日记数据 (文本内容、心情、标签、日记类型、封面图片ID、背景样式JSON、自定义设置JSON、媒体文件信息包括 `attachment_id` 和 `attachment_purpose` 等)。
    *   **后端:** 验证数据，将日记条目与用户ID关联，存入数据库。
    *   **后端API -> 客户端:** 返回成功/失败状态及新创建的日记条目数据。
    *   **客户端:** 更新UI，显示新日记。

3.  **AI辅助写作 (例如：句子补全):**
    *   **客户端:** 用户在编辑器中输入文本，触发AI辅助功能 (例如：点击"补全句子"按钮)。
    *   **客户端 -> 后端API:** 发送当前文本内容、用户选择的AI模型API标识、辅助类型，以及可能从当前日记条目 `custom_settings_json` 中获取的特定AI参数 (例如："sentence_completion")。
    *   **后端 (AI集成服务):**
        *   根据用户选择的AI模型和接收到的参数，准备请求参数和prompt。
        *   从安全存储中获取对应AI模型的API密钥。
        *   **后端 -> 第三方AI服务API:** 发送包含文本和指令的请求。
        *   **第三方AI服务API -> 后端:** 返回AI生成的建议文本。
    *   **后端API -> 客户端:** 返回AI生成的建议文本。
    *   **客户端:** 在UI中向用户展示建议，用户可选择采纳或忽略。

4.  **AI对话式记录日记:**
    *   **客户端:** 用户启动AI对话模式，通过语音或文本输入与AI交互。
    *   **客户端 (语音转文本):** 如果是语音输入，先进行本地或云端语音转文字。
    *   **客户端 -> 后端API:** 发送用户语句、当前对话上下文 (历史消息)、选择的AI模型API标识，以及可能从当前日记草稿/条目的 `custom_settings_json` 中获取的AI交互参数。
    *   **后端 (AI集成服务):**
        *   构建发送给AI模型的对话请求 (包含历史和当前用户输入及相关参数)。
        *   **后端 -> 第三方AI服务API:** 发送对话请求。
        *   **第三方AI服务API -> 后端:** 返回AI的回复 (可能是引导性问题、确认信息或生成的日记片段)。
    *   **后端API -> 客户端:** 返回AI的回复。
    *   **客户端:** 显示AI回复，用户继续对话。此过程可多次迭代。
    *   **(对话结束/保存时) 客户端 -> 后端API:** 用户确认将对话内容整理为日记后，发送最终整理好的日记内容。
    *   **后端:** 将日记条目存入数据库。
    *   **后端API -> 客户端:** 返回成功状态。

5.  **切换AI模型API:**
    *   **客户端:** 用户在设置页面选择不同的AI模型API，可能需要输入新的API密钥 (如果该模型需要用户自备密钥)。
    *   **客户端 -> 后端API:** 发送所选AI模型标识和用户提供的API密钥 (如果适用)。
    *   **后端:**
        *   验证API密钥的有效性 (如果可能，例如通过向AI服务发送一个测试请求)。
        *   在数据库中更新用户的AI模型偏好设置和加密存储的API密钥 (如果由用户提供)。
    *   **后端API -> 客户端:** 返回成功/失败状态。
    *   **客户端:** 更新UI，后续AI功能将使用新选择的模型。

6.  **数据同步 (跨设备):**
    *   **客户端 (设备A):** 用户创建/修改数据。
    *   **客户端 (设备A) -> 后端API:** 发送变更数据。
    *   **后端:** 更新数据库。
    *   **客户端 (设备B):** 定期或在应用启动时向后端API请求最新数据或增量更新。
    *   **后端API -> 客户端 (设备B):** 返回需要同步的数据。
    *   **客户端 (设备B):** 更新本地数据和UI。

### 2.7 人脉关系管理与情商辅助功能数据流 (新增章节)

1.  **创建联系人档案 (手动或AI辅助):**
    *   **客户端:** 用户在特定UI界面输入联系人信息 (姓名、生日、兴趣等) 或提供一段包含相关信息的文本让AI分析。
    *   **(可选 AI辅助信息提取流程)**
        *   **客户端 -> 后端API (`POST /api/v1/ai/assist/contact-profiling`):** 发送待分析文本及可选的 `model_id`。
        *   **后端 (AI集成服务):** 根据请求，选择合适的AI模型，调用AI模型API进行信息提取 (如姓名、兴趣点、偏好、重要日期等)。
        *   **AI模型API -> 后端:** 返回提取的结构化信息。
        *   **后端API -> 客户端:** 返回AI提取的建议信息。
        *   **客户端:** 用户在UI上确认、编辑或补充AI提取的信息。
    *   **客户端 -> 后端API (`POST /api/v1/contacts`):** 发送最终的联系人数据 (包括姓名、昵称、头像URL、关系类型、生日、联系方式JSON、兴趣爱好文本、偏好文本、重要日期JSON、备注、标签等)。
    *   **后端 (人脉关系服务):**
        *   验证数据的有效性和完整性。
        *   将联系人信息存入数据库 `contacts` 表，并关联到当前用户 `user_id`。
        *   如果请求中包含标签信息，则处理 `tags` 表和 `contact_tags` 关联表。
    *   **后端API -> 客户端:** 返回成功响应及新创建的联系人完整数据 (包含 `contact_id`)。
    *   **客户端:** 更新UI，例如将新联系人添加到列表中。

2.  **记录与联系人的互动事件 (可选AI辅助):**
    *   **客户端:** 用户选择一个联系人，然后通过UI记录一次互动事件 (例如：共同晚餐、重要对话、礼物赠送等)。输入互动类型、标题、描述文本、互动日期、地点等信息。
    *   **(可选 AI辅助摘要与情感分析流程)**
        *   **客户端 -> 后端API (例如 `POST /api/v1/ai/assist/writing` 或特定新端点，传递互动描述文本):** 请求对描述文本进行摘要或情感分析。
        *   **后端 (AI集成服务):** 调用AI模型进行文本摘要、关键词提取、情感倾向分析。
        *   **AI模型API -> 后端:** 返回分析结果 (例如建议的摘要文本、情感得分)。
        *   **后端API -> 客户端:** 返回AI分析结果。
        *   **客户端:** 用户可在UI上查看并确认/修改AI生成的摘要或情感标签。
    *   **客户端 -> 后端API (`POST /api/v1/contacts/{contact_id}/interactions`):** 发送完整的互动记录数据 (包括互动类型、标题、描述、日期、地点、可选的AI分析结果如情感得分、金钱往来JSON、关联的日记/清单ID等)。
    *   **后端 (人脉关系服务):**
        *   验证数据。
        *   将互动记录存入数据库 `contact_interactions` 表，关联到用户和指定的联系人。
    *   **后端API -> 客户端:** 返回成功响应及新创建的互动记录数据。
    *   **后端 (异步任务 - 可选):** 此次新的互动记录可能会触发对该联系人关系洞察的重新计算或更新 (例如亲密度评分)。

3.  **查看联系人详情与关系洞察:**
    *   **客户端:** 用户在联系人列表或其他入口点击某个联系人，请求查看其详细信息。
    *   **客户端 -> 后端API (`GET /api/v1/contacts/{contact_id}`):** 发送要查看的联系人ID。
    *   **后端 (人脉关系服务):**
        *   从数据库 `contacts` 表中读取指定联系人的基本档案信息。
        *   (可选聚合) 从 `contact_interactions` 表中查询与该联系人相关的近期互动记录摘要。
        *   (可选聚合) 从 `contact_reminders` 表中查询与该联系人相关的有效提醒。
        *   从 `relationship_insights` 表中查询该联系人最新的关系洞察结果 (例如：亲密度评分、印象关键词等)。
        *   (可选聚合) 从 `contact_tags` 和 `tags` 表中获取该联系人的所有标签。
    *   **后端API -> 客户端:** 返回一个聚合了联系人档案、互动摘要、提醒、洞察和标签等信息的JSON对象。
    *   **客户端:** 渲染联系人详情UI，包括文本信息、列表、以及可能的图表化展示 (如亲密度趋势图、印象词云)。

4.  **AI生成关系维护建议/情商辅助:**
    *   **客户端:** 用户在特定联系人的界面，或在遇到社交困境时，请求AI提供关系建议或沟通技巧。
    *   **客户端 -> 后端API (`POST /api/v1/ai/assist/relationship-suggestion`):** 发送请求，包含目标联系人ID (如果适用)、用户描述的当前情境或问题、期望的建议类型 (例如：维护建议、沟通技巧、礼物建议)。
    *   **后端 (AI集成服务):**
        *   (如果提供了 `contact_id`) 从数据库获取该联系人的档案信息、历史互动摘要、现有关系洞察等作为AI模型的上下文信息。
        *   结合用户提供的情境描述，构建合适的prompt调用AI模型。
    *   **AI模型API -> 后端:** 返回AI生成的建议文本或结构化建议。
    *   **后端API -> 客户端:** 返回AI生成的建议。
    *   **客户端:** 在UI上向用户展示AI建议。

5.  **智能提醒处理流程:**
    *   **(A. 提醒创建 - 手动或AI辅助)**
        *   **手动创建:** 用户通过UI为联系人设置特定日期提醒 (如生日、纪念日)，数据通过 `POST /api/v1/contacts/{contact_id}/reminders` API存入 `contact_reminders` 表。
        *   **AI辅助创建:** AI在分析互动记录或日记内容时，可能识别出潜在的重要日期或承诺。此时，AI集成服务可以通过后端逻辑，或通过客户端交互（例如，AI在聊天中提问"是否需要我为您记录这个纪念日？"），最终建议用户创建提醒。用户确认后，同样通过上述API存入数据库。
    *   **(B. 提醒触发与通知 - 主要由后端处理)**
        *   **后端 (定时任务/调度服务):** 一个独立的后端服务或定时任务 (例如：Cron Job, Celery Beat) 每天或定期查询 `contact_reminders` 表，找出即将到期或当天到期的有效提醒 (`is_active` 为 TRUE)。
        *   对于每个需要触发的提醒，后端服务准备通知内容 (基于提醒的描述和类型)。
        *   **后端 -> 推送通知服务 (例如：Firebase Cloud Messaging - FCM, Apple Push Notification service - APNS):** 后端将通知内容和目标用户设备标识发送给相应的推送服务。
        *   **推送通知服务 -> 客户端设备:** 推送服务将通知推送到用户的设备。
    *   **(C. 用户接收与查看)**
        *   **客户端:** 操作系统层面显示通知。用户点击通知后，应用可被唤醒并导航到相关联系人页面或提醒列表页面。
        *   用户也可以在应用内通过 `GET /api/v1/reminders` (全局提醒) 或 `GET /api/v1/contacts/{contact_id}/reminders` (特定联系人提醒) 查看提醒列表。

## 三、关键考虑因素

*   **安全性:** API密钥的存储与传输、用户数据的加密 (传输中和静态，包括联系人详细信息、互动记录)、防止常见Web漏洞 (XSS, SQL注入等)。
*   **可扩展性:** 后端服务应设计为可水平扩展，以应对用户量增长。数据库选择和设计也需考虑扩展性。**人脉关系服务也应遵循此原则。**
*   **AI模型API的抽象:** 后端应设计一个通用的AI服务接口，以便轻松添加或切换不同的AI模型提供商，而无需大幅修改核心业务逻辑。**此抽象对于人脉相关的AI分析同样重要。**
*   **成本控制:** AI API调用通常是按量付费，需要监控使用情况，并可能需要为用户设置使用限制或提供不同级别的订阅服务。**涉及联系人互动分析和建议生成的AI调用也需纳入成本考量。**
*   **错误处理与容错:** 客户端和后端都需要健壮的错误处理机制，优雅地处理网络问题、AI服务不可用或API错误等情况。
*   **数据隐私:** 明确告知用户AI功能如何使用他们的数据 (**包括联系人信息、互动内容等用于分析和生成建议**)，并遵守相关隐私法规。提供用户控制数据共享和AI分析的选项。
*   **异步处理:** 对于耗时的AI分析任务 (如复杂的亲密度计算、批量联系人信息处理)，应考虑使用异步任务队列 (如Celery, RabbitMQ) 处理，避免阻塞API请求，并及时通过回调或轮询更新客户端状态。

